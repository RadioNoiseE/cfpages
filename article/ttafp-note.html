<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Apple macOS version 5.8.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <meta name="creator" content="RsML1">
  <meta name="author" content="Jing Huang">
  <meta name="pubdate" content="2024-08-18">
  <title>Type Theory and Formal Proof -- Calculus of Constructions with Definitions</title>
  <link href="/favicon.ico" rel="icon">
  <link href="/static/images/minami.jpg" rel="apple-touch-icon">
  <link href="/style/art.css" rel="stylesheet"><script src="/script/math.js"></script><script src=
  "/script/listing.js"></script>
</head>
<body>
  <div class="header">
    <h1 class="title">Type Theory and Formal Proof</h1>
    <h2 class="subtitle">Calculus of Constructions with Definitions</h2>
    <div class="status">
      <p>Published on 18 August 2024 by Jing Huang.</p>
    </div>
    <div class="abstract">
      <p>These notes are based on the book <em>Type Theory and Formal Proof</em> by Rob Nederpelt and Herman
      Geuvers.</p>
    </div>
    <nav id="lot">
      <h2>Table of Contents</h2>
      <div class="toc">
        <ul>
          <li>
            <a href="#c1"><span class="chapno">1</span> <span class="content">Untyped Lambda Calculus</span></a>
            <ul class="toc">
              <li>
                <a href="#s1-1"><span class="secno">1.1</span> <span class="content">Constriction Principles</span></a>
              </li>
              <li>
                <a href="#s1-2"><span class="secno">1.2</span> <span class="content">Lambda Terms</span></a>
              </li>
              <li>
                <a href="#s1-3"><span class="secno">1.3</span> <span class="content">Free and Bound
                Variables</span></a>
              </li>
              <li>
                <a href="#s1-4"><span class="secno">1.4</span> <span class="content">Alpha Conversation</span></a>
              </li>
              <li>
                <a href="#s1-5"><span class="secno">1.5</span> <span class="content">Beta Reduction</span></a>
              </li>
              <li>
                <a href="#s1-6"><span class="secno">1.6</span> <span class="content">Fixed Point Theorem</span></a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#c2"><span class="chapno">2</span> <span class="content">Simply Typed Lambda Calculus</span></a>
            <ul class="toc">
              <li>
                <a href="#s2-1"><span class="secno">2.1</span> <span class="content">Simple Types</span></a>
              </li>
              <li>
                <a href="#s2-2"><span class="secno">2.2</span> <span class="content">Church and Curry Typing</span></a>
              </li>
              <li>
                <a href="#s2-3"><span class="secno">2.3</span> <span class="content">Derivation Rules for Church's
                <span class="math">\(\lambda_\to\)</span></span></a>
              </li>
              <li>
                <a href="#s2-4"><span class="secno">2.4</span> <span class="content">Well-Typedness in <span class=
                "math">\(\lambda_\to\)</span></span></a>
              </li>
              <li>
                <a href="#s2-5"><span class="secno">2.5</span> <span class="content">Type Checking in <span class=
                "math">\(\lambda_\to\)</span></span></a>
              </li>
              <li>
                <a href="#s2-6"><span class="secno">2.6</span> <span class="content">Term Finding in <span class=
                "math">\(\lambda_\to\)</span></span></a>
              </li>
              <li>
                <a href="#s2-7"><span class="secno">2.7</span> <span class="content">General Properties of <span class=
                "math">\(\lambda_\to\)</span></span></a>
              </li>
              <li>
                <a href="#s2-8"><span class="secno">2.8</span> <span class="content">Reduction and <span class=
                "math">\(\lambda_\to\)</span></span></a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#c3"><span class="chapno">3</span> <span class="content">Second Order Typed Lambda
            Calculus</span></a>
            <ul class="toc">
              <li>
                <a href="#s3-1"><span class="secno">3.1</span> <span class="content"><span class="math">\(\Pi\)</span>
                Types</span></a>
              </li>
              <li>
                <a href="#s3-2"><span class="secno">3.2</span> <span class="content">Second Order Abstraction and
                Application Rules</span></a>
              </li>
              <li>
                <a href="#s3-3"><span class="secno">3.3</span> <span class="content">The System <span class=
                "math">\(\lambda2\)</span></span></a>
              </li>
              <li>
                <a href="#s3-4"><span class="secno">3.4</span> <span class="content">Properties of <span class=
                "math">\(\lambda2\)</span></span></a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#c4"><span class="chapno">4</span> <span class="content">Types Dependent on Types</span></a>
            <ul class="toc">
              <li>
                <a href="#s4-1"><span class="secno">4.1</span> <span class="content">Type Constructors</span></a>
              </li>
              <li>
                <a href="#s4-2"><span class="secno">4.2</span> <span class="content">Sort and Variable in <span class=
                "math">\(\lambda\underline{\omega\!}\,\)</span></span></a>
              </li>
              <li>
                <a href="#s4-3"><span class="secno">4.3</span> <span class="content">Weakening Rule in <span class=
                "math">\(\lambda\underline{\omega\!}\,\)</span></span></a>
              </li>
              <li>
                <a href="#s4-4"><span class="secno">4.4</span> <span class="content">Formation Rule in <span class=
                "math">\(\lambda\underline{\omega\!}\,\)</span></span></a>
              </li>
              <li>
                <a href="#s4-5"><span class="secno">4.5</span> <span class="content">Application and Abstraction Rules
                in <span class="math">\(\lambda\underline{\omega\!}\,\)</span></span></a>
              </li>
              <li>
                <a href="#s4-6"><span class="secno">4.6</span> <span class="content">Conversion Rule</span></a>
              </li>
              <li>
                <a href="#s4-7"><span class="secno">4.7</span> <span class="content">Properties of <span class=
                "math">\(\lambda\underline{\omega\!}\,\)</span></span></a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#c5"><span class="chapno">5</span> <span class="content">Type Dependent on Terms</span></a>
            <ul class="toc">
              <li>
                <a href="#s5-1"><span class="secno">5.1</span> <span class="content">Derivation Rules of <span class=
                "math">\(\lambda P\)</span></span></a>
              </li>
              <li>
                <a href="#s5-2"><span class="secno">5.2</span> <span class="content">Minimal Predicate Logic</span></a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </nav>
  </div>
  <h2 id="c1">1. Untyped Lambda Calculus</h2>
  <p><em>Lambda calculus</em> encapsulates a formation of the basic aspects of functions. Untyped lambda calculus means
  we do not consider the types in this chapter.</p>
  <h3 id="s1-1">1.1. Constriction Principles</h3>
  <ul>
    <li><em>Abstraction</em>: From an expression <span class="math">\(M\)</span> and a variable <span class=
    "math">\(x\)</span> we can construct a new expression <span class="math">\(\lambda x.M\)</span>. We call this the
    abstraction of <span class="math">\(x\)</span> over <span class="math">\(M\)</span>.</li>
    <li><em>Application</em>: From expressions <span class="math">\(M\)</span> and <span class="math">\(N\)</span> we
    can construct expression <span class="math">\(MN\)</span>. We call this application of <span class=
    "math">\(M\)</span> to <span class="math">\(N\)</span>.</li>
  </ul>
  <h3 id="s1-2">1.2. Lambda Terms</h3>
  <p>Expressions in the lambda calculus are called <em>lambda terms</em>. We assume the existence of an infinite set
  <span class="math">\(V=\{x,y,z,\ldots\}\)</span> of so-called <em>variables</em> while the below inductive definition
  establishes how the set <span class="math">\(\Lambda\)</span> of all lambda terms are constructed:</p>
  <ol>
    <li><em>Variable</em>: If <span class="math">\(u\in V\)</span>, then <span class=
    "math">\(u\in\Lambda\)</span>.</li>
    <li><em>Application</em>: If <span class="math">\(M\)</span> and <span class="math">\(N\in\Lambda\)</span>, then
    <span class="math">\((MN)\in\Lambda\)</span>.</li>
    <li><em>Abstraction</em>: If <span class="math">\(u\in V\)</span> and <span class="math">\(M\in\Lambda\)</span>,
    then <span class="math">\((\lambda u.M)\in\Lambda\)</span>.</li>
  </ol>
  <p>An <em>inductive definition</em> of <span class="math">\(\Lambda\)</span> means that the above definitions are the
  only ways to construct elements of <span class="math">\(\Lambda\)</span>. An alternative and shorter way is to define
  <span class="math">\(\Lambda\)</span> via <em>abstract syntax</em>:</p>
  <div class="math">
    \[\Lambda=V\mid(\Lambda\Lambda)\mid(\lambda V.\Lambda).\]
  </div>
  <p>The <em>syntactical identity</em> of two lambda terms can be denoted with the symbol <span class=
  "math">\(\equiv\)</span>.</p>
  <p>The <em>subterms</em> of a given lambda term form a <em>multiset</em>:</p>
  <ol>
    <li><em>Basis</em>: <span class="math">\(\mathcal S(x)=x\)</span>, for each <span class="math">\(x\in
    V\)</span>.</li>
    <li><em>Application</em>: <span class="math">\(\mathcal S((MN))=\mathcal S(M)\cup\mathcal
    S(N)\cup\{(MN)\}\)</span>.</li>
    <li><em>Abstraction</em>: <span class="math">\(\mathcal S((\lambda x.M))=\mathcal S(M)\cup\{(\lambda
    x.M)\}\)</span>.</li>
  </ol>
  <p>They follow <em>reflexivity</em> and <em>transitivity</em>. A proper subterm of <span class="math">\(M\)</span> is
  <span class="math">\(L\)</span> if <span class="math">\(L\not\equiv M\)</span>.</p>
  <p>The expression have the following precedence and associativity:</p>
  <ul>
    <li>Parentheses in an outermost position may be omitted.</li>
    <li>Application is <em>left-associative</em>.</li>
    <li>Application takes precedence over abstraction.</li>
    <li>Successive abstractions may be combined in a <em>right-associative</em> way under one <span class=
    "math">\(\lambda\)</span>.</li>
  </ul>
  <h3 id="s1-3">1.3. Free and Bound Variables</h3>
  <p>Variable occurrences in a lambda term can be divided into three categories: <em>free</em> occurrences,
  <em>bound</em> occurrences and <em>binding</em> occurrences.</p>
  <p>Binding variables are those occurred immediately after a <span class="math">\(\lambda\)</span>. In the
  construction of a lambda term, the single variable and the variables that aren't bound by the binding variables are
  free variables. However, during the process of abstraction, an occurrence of <span class="math">\(x\)</span> which is
  free in <span class="math">\(M\)</span> becomes bound in <span class="math">\(\lambda x.M\)</span>; that is,
  abstraction of <span class="math">\(x\)</span> over <span class="math">\(M\)</span> binds all free occurrences of
  <span class="math">\(X\)</span> in <span class="math">\(M\)</span>.</p>
  <p>Then we have the following recursive rule, in which <span class="math">\(\mathcal F(L)\)</span> denotes the set of
  free variables in the lambda term <span class="math">\(L\)</span>.</p>
  <ol>
    <li><em>Variable</em>: <span class="math">\(\mathcal F(x)=\{x\}\)</span>.</li>
    <li><em>Application</em>: <span class="math">\(\mathcal F(MN)=\mathcal F(M)\cup\mathcal F(N)\)</span>.</li>
    <li><em>Abstract</em>: <span class="math">\(\mathcal F(\lambda x.M)=\mathcal F(M)\setminus\{x\}\)</span>.</li>
  </ol>
  <p>The lambda term is <em>closed</em> if <span class="math">\(\mathcal F(M)=\emptyset\)</span>. A closed set is also
  called a <em>combinator</em>. The set of all closed lambda terms is denoted by <span class=
  "math">\(\Lambda^0\)</span>.</p>
  <h3 id="s1-4">1.4. Alpha Conversation</h3>
  <p>Functions in the lambda notation have the property that the <em>name</em> of the binding variable is not
  essential; the name is only used to express the transformation or procedure from input to output. Thus the relation
  <em>alpha conversation</em> or <em>alpha equivalence</em> is defined to describe this process formally. It's based on
  the possibility of renaming binding (and bound) variables.</p>
  <p><span class="math">\(M^{x\to y}\)</span> denote the result of replacing every free occurrence of <span class=
  "math">\(x\)</span> in <span class="math">\(M\)</span> by <span class="math">\(y\)</span>. The relation <span class=
  "math">\(\lambda x.M=_\alpha\lambda y.M^{x\to y}\)</span> is called <em>renaming</em>.</p>
  <p>In the renaming of <span class="math">\(\lambda x.M\)</span> to <span class="math">\(\lambda y.M^{x\to
  y}\)</span>, it is prevented that the <em>new</em> binding variable <span class="math">\(y\)</span> binds
  <em>old</em> free <span class="math">\(y\)</span>s; and that any <em>old</em> binding <span class="math">\(y\)</span>
  binds a <em>new</em> <span class="math">\(y\)</span>.</p>
  <p>Alpha conversation follows <em>compatibility</em>, <em>reflectivity</em>, <em>symmetry</em> and
  <em>transitivity</em>. If <span class="math">\(M\)</span> and <span class="math">\(N\)</span> are said to be
  <em>alpha convertible</em> or <em>alpha equivalent</em>, then <span class="math">\(M\)</span> is called an <em>alpha
  variant</em> of <span class="math">\(N\)</span>.</p>
  <p>We can abstract from the names of the bound (and binding) variables, by considering lambda terms <em>modulo alpha
  equivalence</em>.</p>
  <h3 id="s1-5">1.5. Beta Reduction</h3>
  <ol>
    <li><em>Basis</em>: <span class="math">\((\lambda x.M)N\to_\beta M[x:=N]\)</span>.</li>
    <li><em>Compatibility</em>: If <span class="math">\(M\to_\beta N\)</span>, then <span class="math">\(ML\to_\beta
    NL\)</span>, <span class="math">\(LM\to_\beta NL\)</span> and <span class="math">\(\lambda x.M\to_\beta \lambda
    x.N\)</span>.</li>
  </ol>
  <p>The suffix <span class="math">\([x:=N]\)</span> not in lambda terms, are meant to be <em>meta-notation</em> called
  substitution, which follow:</p>
  <ul>
    <li><span class="math">\(x[x:=N]\equiv N\)</span>, <span class="math">\(y[x:=N]\equiv y\)</span> if <span class=
    "math">\(x\not\equiv y\)</span>.</li>
    <li><span class="math">\((PQ)[x:=N]\equiv(P[x:=N])(Q[x:=N])\)</span>.</li>
    <li><span class="math">\((\lambda y.P)[x:=N]\equiv\lambda z.(P^{y\to z}[x:=N])\)</span>, if <span class=
    "math">\(\lambda z.P^{y\to z}\)</span> is an alpha variant of <span class="math">\(\lambda y.P\)</span> such that
    <span class="math">\(z\notin\mathcal F(N)\)</span>.</li>
  </ul>
  <p>The subterm of the form <span class="math">\((\lambda x.M)N\)</span> is called a <em>redex</em> (from reducible
  expression) and subterm <span class="math">\(M[x:=N]\)</span> is called the <em>contractum</em> (of the redex).</p>
  <p>Note that in general, the substitutions <span class="math">\(M[x:=N][y:=L]\)</span> does not describe the same
  lambda term as <span class="math">\(M[y:=L][x:=N]\)</span> because of the left associativity (<span class=
  "math">\(M[x:=N][y:=L]\equiv M[y:=L][x:=N[y:=L]]\land x\notin\mathcal F(L)\)</span>).</p>
  <p>We define the relation <span class="math">\(\to_\beta\)</span> to be one-step beta reduction since one redex is
  replaced by its contractum. The further beta reduction performed after the one-step reduction can be defined using
  <span class="math">\(\twoheadrightarrow_\beta\)</span> which generally take zero or more step. We can prove that
  <span class="math">\(\twoheadrightarrow_\beta\)</span> is <em>reflective</em> and <em>transitive</em>.</p>
  <p>Similar to alpha conversation, we can define <em>beta conversation</em> or <em>beta equivalence</em>. If
  <span class="math">\(M=_\beta N\)</span> and there is an <span class="math">\(n\geq 0\)</span> and there are terms
  <span class="math">\(M_0\)</span> or <span class="math">\(M_n\)</span> such that <span class="math">\(M_0\equiv
  M\)</span>, <span class="math">\(M_n\equiv N\)</span> for all <span class="math">\(i\)</span> such that <span class=
  "math">\(0\leq i&lt;n\)</span>:</p>
  <div class="math">
    \[M_i\to_\beta M_{i+1}\lor M_{i+1}\to_\beta M_i.\]
  </div>
  <p><span class="math">\(\twoheadrightarrow_\beta\)</span> extends <span class="math">\(\to_\beta\)</span> to
  multi-steps, while <span class="math">\(=_\beta\)</span> further extends <span class=
  "math">\(\twoheadrightarrow_\beta\)</span> in both directions. Thus <span class="math">\(=_\beta\)</span> is
  <em>reflective</em>, <em>symmetric</em> and <em>transitive</em>.</p>
  <ul>
    <li><span class="math">\(M\)</span> is in <em>beta normal</em> form if <span class="math">\(M\)</span> does not
    contain any redex.</li>
    <li><span class="math">\(M\)</span> is <em>beta normalizing</em> if there is an <span class="math">\(N\)</span> in
    beta normal form such that <span class="math">\(M=_\beta N\)</span>.</li>
  </ul>
  <p>A <em>reduction path</em> from <span class="math">\(M\)</span> is an infinite or finite sequence <span class=
  "math">\(N_0,N_1,N_2,\ldots\)</span> that is connected using one-step beta reduction that starts from <span class=
  "math">\(M\)</span>.</p>
  <ul>
    <li><span class="math">\(M\)</span> is <em>weakly normalizing</em> if there is an <span class="math">\(N\)</span>
    in the beta normal form such that <span class="math">\(M\twoheadrightarrow_\beta N\)</span>. (<em>One of</em> the
    reduction path leads to an outcome.)</li>
    <li><span class="math">\(M\)</span> is <em>strongly normalizing</em> if there are no infinite reduction paths
    starting from <span class="math">\(M\)</span>. (<em>Each</em> reduction path leads to an outcome.)</li>
  </ul>
  <p>Suppose that for a given lambda term <span class="math">\(M\)</span>, we have <span class=
  "math">\(M\twoheadrightarrow_\beta N_i\)</span> and <span class="math">\(M\twoheadrightarrow_\beta N_2\)</span>, then
  there is a lambda term <span class="math">\(N_3\)</span> such that <span class="math">\(N_1\twoheadrightarrow_\beta
  N_3\)</span> and <span class="math">\(N_2\twoheadrightarrow_\beta N_3\)</span>. This is the <em>Church-Rosser
  Theorem</em>.</p>
  <h3 id="s1-6">1.6. Fixed Point Theorem</h3>
  <p>Every lambda term <span class="math">\(L\)</span> has a <em>fixed point</em>, which can be constructed using a
  <em>fixed point combinator</em>. One instance is:</p>
  <div class="math">
    \[Y\equiv\lambda y.(\lambda x.y(xx))(\lambda x.y(xx)).\]
  </div>
  <p>Then we have <span class="math">\(YL\)</span> which is a fixed point of <span class="math">\(L\)</span>, since
  <span class="math">\(L(YL)=_\beta YL\)</span>, which can be shown as follows:</p>
  <div class="math">
    \[\begin{align} YL&amp;\to_\beta(\lambda x.L(xx))(\lambda x.L(xx))\\ &amp;\to_\beta L((\lambda x.L(xx))(\lambda
    x.L(xx)))\\ &amp;=_\beta L(YL). \end{align}\]
  </div>
  <h2 id="c2">2. Simply Typed Lambda Calculus</h2>
  <p>In order to get a firmer hold on the desired behavior of functions, we introduce <em>types</em>. Functions are
  been classified to a certain collection, and certain restrictions on the input values are given.</p>
  <p>The <em>simple types</em> introduced in this chapter prevents the anomalies but are also in several senses too
  restrictive. We will enlarge the expressivity of the system in subsequent chapters.</p>
  <h3 id="s2-1">2.1. Simple Types</h3>
  <p>We first define an infinite set of type <em>variables</em> <span class=
  "math">\(\mathbb{V}=\{\alpha,\beta,\gamma,\ldots\}.\)</span> and then define the set of simple types <span class=
  "math">\(\mathbb{T}\)</span>:</p>
  <ol>
    <li><em>Type variable</em>: If <span class="math">\(\alpha\in\mathbb{V}\)</span>, then <span class=
    "math">\(\alpha\in\mathbb{T}\)</span>.</li>
    <li><em>Arrow type</em>: If <span class="math">\(\sigma,\tau\in\mathbb{T}\)</span>, then <span class=
    "math">\((\sigma\to\tau)\in\mathbb{T}\)</span>.</li>
  </ol>
  <p>It can be expressed using abstract syntax as <span class=
  "math">\(\mathbb{T}=\mathbb{V}\mid\mathbb{T}\to\mathbb{T}\)</span>.</p>
  <p>The Greek letters <span class="math">\(\alpha,\beta,\gamma,\ldots\)</span> and variants are used for type
  variables belonging to <span class="math">\(\mathbb{V}\)</span>. Arbitrary simple types are denoted using
  <span class="math">\(\sigma,\tau,\ldots\)</span>. Their outermost parentheses may be <em>omitted</em> and for
  arrow-types, they are <em>right-associative</em>.</p>
  <p>Type variables are abstract representations of <em>basic types</em>, such as <span class="math">\(nat\)</span> for
  natural numbers or <span class="math">\(list\)</span> for lists. Arrow types represent <em>function types</em>, such
  as <span class="math">\(nat\to real\)</span> which abstracts a function which input is a natural number and the
  returned result is a real number.</p>
  <p>We also have <em>statements</em> which allow us to express something like <q>term <span class="math">\(M\)</span>
  has type <span class="math">\(\sigma\)</span></q> in the form <span class="math">\(M:\sigma\)</span>. We assume we
  have infinitude of variables available for each type <span class="math">\(\sigma\)</span>, thus we assume that each
  variable <span class="math">\(x\)</span> has a unique type: if <span class="math">\(x:\sigma\)</span> and
  <span class="math">\(x:\tau\)</span>, then <span class="math">\(\sigma\equiv\tau\)</span>.</p>
  <p>By adding typing to the basic construction principles of lambda calculus, we have:</p>
  <ol>
    <li><em>Application</em>: If <span class="math">\(M:\sigma\to\tau\)</span> and <span class=
    "math">\(N:\sigma\)</span>, then <span class="math">\(MN:\tau\)</span>.</li>
    <li><em>Abstraction</em>: If <span class="math">\(x:\sigma\)</span> and <span class="math">\(M:\tau\)</span>, then
    <span class="math">\(\lambda x.M:\sigma\to\tau\)</span>.</li>
  </ol>
  <p>There are two <em>side conditions</em> which have to be satisfied in the typing of an application <span class=
  "math">\(MN\)</span>: the left-hand side <span class="math">\(M\)</span> of the application must have a function type
  <span class="math">\(\sigma\to\tau\)</span> while the right-hand side <span class="math">\(N\)</span> of the
  application must match with the input type <span class="math">\(\sigma\)</span>; the output type will then be
  <span class="math">\(\tau\)</span>. For abstraction <span class="math">\(\lambda x.M\)</span>, we just need the types
  of <span class="math">\(x\)</span> and <span class="math">\(M\)</span>.</p>
  <p>A term <span class="math">\(M\)</span> is called <em>typable</em> if there is a type <span class=
  "math">\(\sigma\)</span> such that <span class="math">\(M:\sigma\)</span>.</p>
  <h3 id="s2-2">2.2. Church and Curry Typing</h3>
  <p>To type a lambda term, we should first type its variables. We can give types to variables in two ways:</p>
  <ol>
    <li><em>Typing à la Church</em>: also called <em>explicit typing</em>, that we prescribe a (unique) type for each
    variable upon its introduction.</li>
    <li><em>Typing à la Curry</em>: also called <em>implicit typing</em>, which type is left open to some extent. We
    find typable terms by a search process, which may involve guesses for the types of the variables.</li>
  </ol>
  <p>We denote the types of bound variables immediately after their introduction following a <span class=
  "math">\(\lambda\)</span> while the types of free variables are given in a so-called <em>context</em>
  (<em>basis</em>):</p>
  <div class="math">
    \[x:\alpha\to\alpha,y:(\alpha\to\alpha)\to\beta\vdash(\lambda z:\beta.\lambda u:\gamma.z)(yx): \gamma\to\beta.\]
  </div>
  <h3 id="s2-3">2.3. Derivation Rules for Church's <span class="math">\(\lambda_\to\)</span></h3>
  <p>The definition of lambda terms have to be modified to incorporate type information. This new set of pre-typed
  <span class="math">\(\Lambda_\mathbb{T}\)</span> is defined by <span class=
  "math">\(\Lambda_\mathbb{T}=V\mid(\Lambda_\mathbb{T}\Lambda_\mathbb{T})\mid(\lambda
  V:\mathbb{T}.\Lambda_\mathbb{T})\)</span>.</p>
  <p>A <em>judgment</em> has the form <span class="math">\(\Gamma\vdash M:\sigma\)</span>, with <span class=
  "math">\(\Gamma\)</span> a context and <span class="math">\(M:\sigma\)</span> a statement.</p>
  <ol>
    <li><em>Statement</em>: <span class="math">\(M:\sigma\)</span>, where <span class=
    "math">\(M\in\Lambda_\mathbb{T}\)</span> and <span class="math">\(\sigma\in\mathbb{T}\)</span>.</li>
    <li><em>Declaration</em>: a statement with a variable as subject.</li>
    <li><em>Context</em>: a list of declarations with different subjects.</li>
  </ol>
  <p>Below we give three <em>derivation rules</em> to form a so-called <em>derivation system</em> for Church's
  <span class="math">\(\lambda_\to\)</span> in the <em>premiss-conclusion</em> format.</p>
  <div class="math">
    \[\begin{array}{lc} (var)&amp;\begin{prooftree}\AXC{$x:\sigma\in\Gamma$}\UIC{$y\vdash x:\sigma$}\end{prooftree}\\
    (appl)&amp;\begin{prooftree}\AXC{$\Gamma\vdash M:\sigma\to\tau$}\AXC{$\Gamma\vdash N:\sigma$}\BIC{$\Gamma\vdash
    MN:\tau$}\end{prooftree}\\ (abst)&amp;\begin{prooftree}\AXC{$\Gamma,x:\sigma\vdash
    M:\tau$}\UIC{$\Gamma\vdash\lambda x:\sigma,M:\sigma\to\tau$}\end{prooftree} \end{array}\]
  </div>
  <p>A pre-typed term <span class="math">\(\lambda_\to\)</span> is called <em>legal</em> if there exist context
  <span class="math">\(\Gamma\)</span> and type <span class="math">\(\rho\)</span> such that <span class=
  "math">\(\Gamma\vdash M:\rho\)</span>.</p>
  <h3 id="s2-4">2.4. Well-Typedness in <span class="math">\(\lambda_\to\)</span></h3>
  <p>This is one of the three problems connected with judgments in type theory: to find an appropriate context and type
  if the term is indeed legal.</p>
  <p>For example, we want to show <span class="math">\(M\equiv\lambda y:\alpha\to\beta.\lambda z:\alpha.yz\)</span> is
  valid. Hence, our task is to find a type <span class="math">\(\rho\)</span> such that <span class=
  "math">\(\Gamma\vdash M:\rho\)</span>. First we determine the context <span class="math">\(\Gamma\)</span> which
  <span class="math">\(\Gamma\equiv\emptyset\)</span> suffices since there are no free variables in <span class=
  "math">\(M\)</span>. Then we need to find <span class="math">\(\rho\)</span>.</p>
  <div class="math">
    \[\begin{prooftree} \AXC{$y:\alpha\to\beta$}\AXC{$z:\alpha$}\BIC{$y:\alpha\to\beta,z:\alpha\vdash yz:\beta$}
    \UIC{$y:\alpha\to\beta\vdash\lambda z:\alpha.yz:\alpha\to\beta$} \UIC{$\lambda y:\alpha\to\beta.\lambda
    z:\alpha.yz:(\alpha\to\beta)\to(\alpha\to\beta)$} \end{prooftree}\]
  </div>
  <p>Thus we can conclude that <span class="math">\(\lambda y.\alpha\to\beta.\lambda z:\alpha.yz\)</span> is valid
  since we find <span class="math">\(\rho\)</span> which is <span class=
  "math">\((\alpha\to\beta)\to(\alpha\to\beta)\)</span>.</p>
  <h3 id="s2-5">2.5. Type Checking in <span class="math">\(\lambda_\to\)</span></h3>
  <p>The name type checking is straightforward, it means to check the validity of a full judgment.</p>
  <p>As an example, we can construct a derivation for <span class=
  "math">\(x:\alpha\to\alpha,y:(\alpha\to\alpha)\to\beta \vdash(\lambda z:\beta.\lambda
  u:\gamma.z)(yz):\gamma\to\beta\)</span>.</p>
  <div class="math">
    \[\begin{prooftree}
    \AXC{$x:\alpha\to\alpha$}\AXC{$y:(\alpha\to\alpha)\to\beta$}\BIC{$x:\alpha\to\alpha,y:(\alpha\to\alpha)\to\beta\vdash
    yx:\beta$} \AXC{$z:\beta$}\AXC{$u:\gamma$}\BIC{$z:\beta,u:\gamma\vdash\lambda z:\beta.\lambda
    u:\gamma.z:\beta\to\gamma\to\beta$} \BIC{$(\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma\to\beta$}
    \end{prooftree}\]
  </div>
  <p>Hence we have succeeded in giving a proper deviation of the judgment.</p>
  <h3 id="s2-6">2.6. Term Finding in <span class="math">\(\lambda_\to\)</span></h3>
  <p>This section presents the third of the general problem in type theory, namely to find an appropriate term of a
  certain type, in a certain context. A term which belongs to a certain type is called an <em>inhabitant</em> of that
  type.</p>
  <p>To find an inhabitant of a certain type, we can think of the type as <em>proposition</em>, while each inhabitant
  codes a <em>proof</em> of this proposition.</p>
  <p>For instance, to find the term of <span class="math">\(A\to B\to A\)</span>, we can follow:</p>
  <ol>
    <li>Assume that <span class="math">\(x\)</span> is a proof of proposition <span class="math">\(A\)</span>.</li>
    <li>Also assume that <span class="math">\(y\)</span> is a proof of proposition <span class=
    "math">\(B\)</span>.</li>
    <li>Then <span class="math">\(x\)</span> is still a proof of <span class="math">\(A\)</span>.</li>
    <li>So the function mapping <span class="math">\(y\)</span> to <span class="math">\(x\)</span> sends a proof of
    <span class="math">\(B\)</span> to a proof of <span class="math">\(A\)</span>, i.e., <span class="math">\(\lambda
    y:B.x\)</span> proves the implication <span class="math">\(B\to A\)</span>.</li>
    <li>Consequently, <span class="math">\(\lambda z:A.\lambda y:B.x\)</span> proves <span class="math">\(A\to B\to
    A\)</span>.</li>
  </ol>
  <p>The above process is generally called the <em>PAT-interpretation</em>, where PAT means both
  <q>propositions-as-types</q> and <q>proofs-as-terms</q>.</p>
  <h3 id="s2-7">2.7. General Properties of <span class="math">\(\lambda_\to\)</span></h3>
  <p>We give a number of definitions about context below:</p>
  <ol>
    <li>If <span class="math">\(\Gamma\equiv x_1:\sigma_1,\ldots,x_n:\sigma_n\)</span>, then the <em>domain</em> of
    <span class="math">\(\Gamma\)</span> or <span class="math">\(\mathcal D(\Gamma)\)</span> is the list <span class=
    "math">\((x_1,\ldots,x_n)\)</span>.</li>
    <li>Context <span class="math">\(\Gamma'\)</span> is a <em>subcontext</em> of context <span class=
    "math">\(\Gamma\)</span>, or <span class="math">\(\Gamma'\subseteq\Gamma\)</span>, if all declarations occurring in
    <span class="math">\(\Gamma'\)</span> also occur in <span class="math">\(\Gamma\)</span>, in the same order.</li>
    <li>Context <span class="math">\(\Gamma'\)</span> is a <em>permutation</em> of context <span class=
    "math">\(\Gamma\)</span>, if all declarations in <span class="math">\(\Gamma'\)</span> also occur in <span class=
    "math">\(\Gamma\)</span>, and vice versa.</li>
    <li>If <span class="math">\(\Gamma\)</span> is a context and <span class="math">\(\Phi\)</span> is a set of
    variables, then the <em>projection</em> of <span class="math">\(\Gamma\)</span> on <span class=
    "math">\(\Phi\)</span>, or <span class="math">\(\Gamma\upharpoonright\Phi\)</span>, is the subcontext <span class=
    "math">\(\Gamma'\)</span> of <span class="math">\(\Gamma\)</span> with <span class="math">\(\mathcal
    D(\Gamma')=\mathcal D(\Gamma)\cap\Phi\)</span>.</li>
  </ol>
  <p>An important property concerning the free variables occurring in a judgment is that if <span class=
  "math">\(\Gamma\vdash L:\sigma\)</span>, then <span class="math">\(\mathcal F(L)\subseteq\mathcal D(\Gamma)\)</span>.
  This can be proved by induction on the deviation of the judgment <span class="math">\(\mathcal J\equiv\Gamma\vdash
  L:\sigma\)</span>.</p>
  <p>We continue with three other properties which are trivial and can also be proved by induction.</p>
  <ol>
    <li><em>Thinning</em>: Let <span class="math">\(\Gamma'\)</span> and <span class="math">\(\Gamma''\)</span> be
    contexts such that <span class="math">\(\Gamma'\subseteq\Gamma''\)</span>. If <span class="math">\(\Gamma'\vdash
    M:\sigma\)</span>, then also <span class="math">\(\Gamma''\vdash M:\sigma\)</span>.</li>
    <li><em>Condensing</em>: If <span class="math">\(\Gamma\vdash M:\sigma\)</span>, then also <span class=
    "math">\(\Gamma\upharpoonright\mathcal F(M)\vdash M:\sigma\)</span>.</li>
    <li><em>Permutation</em>: If <span class="math">\(\Gamma\vdash M:\sigma\)</span>, and <span class=
    "math">\(\Gamma'\)</span> is a permutation of <span class="math">\(\Gamma\)</span>, then <span class=
    "math">\(\Gamma'\)</span> is also a context and moreover, <span class="math">\(\Gamma'\vdash
    M:\sigma\)</span>.</li>
  </ol>
  <p>The <em>Generation Lemma</em>, which says precisely how a certain judgment can be generated, is shown below:</p>
  <ol>
    <li>If <span class="math">\(\Gamma\vdash x:\sigma\)</span>, then <span class=
    "math">\(x:\sigma\in\Gamma\)</span>.</li>
    <li>If <span class="math">\(\Gamma\vdash MN:\tau\)</span>, then there is a type <span class=
    "math">\(\sigma\)</span> such that <span class="math">\(\Gamma\vdash M:\sigma\to\tau\)</span> and <span class=
    "math">\(\Gamma\vdash N:\sigma\)</span>.</li>
    <li>If <span class="math">\(\Gamma\vdash\lambda x:\sigma.M:\rho\)</span>, then there is <span class=
    "math">\(\tau\)</span> such that <span class="math">\(\Gamma,x:\sigma\vdash M:\tau\)</span> and <span class=
    "math">\(\rho\equiv\sigma\to\tau\)</span>.</li>
  </ol>
  <p>It's obvious that, in order to build a legal term, its subterms should be legal too. This is the <em>Subterm
  Lemma</em>.</p>
  <p>Another important property which applies for Church's <span class="math">\(\lambda_\to\)</span> is that, a term
  may have <em>at most one</em> type. This ensures that the type, if exists, must be unique. Therefore we also have the
  <em>uniqueness of types</em>.</p>
  <h3 id="s2-8">2.8. Reduction and <span class="math">\(\lambda_\to\)</span></h3>
  <p>In order to be able to treat substitution, an operation at the heart of beta reduction, in <span class=
  "math">\(\lambda_\to\)</span>, we have to append type information. We then have the <em>Substitution Lemma</em>:
  assume <span class="math">\(\Gamma',x:\sigma,\Gamma''\vdash M:\tau\)</span> and <span class="math">\(\Gamma'\vdash
  N:\sigma\)</span>; then <span class="math">\(\Gamma',\Gamma''\vdash M[x:=N]:\tau\)</span>. This means that if we
  substitute all occurrences of context variable by a term of the same type, the result type is unchanged which is
  intuitively understandable.</p>
  <p>We also have to adjust the definition for beta reduction to the (pre-typed) terms of <span class=
  "math">\(\Lambda_\mathbb{T}\)</span>:</p>
  <ol>
    <li><em>Basis</em>: <span class="math">\((\lambda x:\sigma.M)N\to_\beta M[x:=N]\)</span>.</li>
    <li><em>Compatibility</em>: If <span class="math">\(M\to_\beta N\)</span>, then <span class="math">\(ML\to_\beta
    NL\)</span>, <span class="math">\(LM\to_\beta NL\)</span> and <span class="math">\(\lambda x:\tau.M\to_\beta
    \lambda x:\tau.N\)</span>.</li>
  </ol>
  <p>The Church-Rosser Theorem is still valid as types clearly play no role in the reduction process.</p>
  <p>The <em>Subject Reduction</em> states that beta reduction does not affect typability, and even does not change the
  term's type: if <span class="math">\(\Gamma\vdash L:\rho\)</span> and if <span class=
  "math">\(L\twoheadrightarrow_\beta L'\)</span>, then <span class="math">\(\Gamma\vdash L':\rho\)</span>. Proof can be
  done by inducting the one basic and three compatibility cases of beta reduction.</p>
  <p>Finally, one can prove that there are no infinite reduction sequences in <span class=
  "math">\(\lambda_\to\)</span>, or every legal term is strongly normalization. This is the <em>String Normalization
  Theorem</em> or <em>Termination Theorem</em>.</p>
  <h2 id="c3">3. Second Order Typed Lambda Calculus</h2>
  <p>In Church's <span class="math">\(\lambda_\to\)</span>, we only encounter abstraction and application on the term
  level, which is <em>first order</em>, as abstraction and application are over <em>terms</em>. In the present chapter,
  <em>second order</em> operations, or terms depending on types, are introduced.</p>
  <p>This is called the <em>second order lambda calculus</em>, written as <span class="math">\(\lambda2\)</span> for
  short.</p>
  <h3 id="s3-1">3.1. <span class="math">\(\Pi\)</span> Types</h3>
  <p>To construct a function that can handle terms of different types, we can consider an <em>arbitrary</em> type, and
  use this type as another abstraction for our function <span class="math">\(\lambda\alpha:*.\lambda
  x:\alpha.x\)</span>.</p>
  <p>This function receives a type variable <span class="math">\(\alpha\)</span>, while the <span class=
  "math">\(*\)</span> symbol denotes <em>the type of all types</em>. The function acts as a term depending on a type,
  thus is second ordered or <em>polymorphic</em>.</p>
  <p>To type this polymorphic term, we introduce a new <em>binder</em>, the <span class="math">\(\Pi\)</span> binder.
  We can then express the type of the polymorphic function created earlier as <span class=
  "math">\(\Pi\alpha:*.\alpha\to\alpha\)</span>.</p>
  <p>By an obvious extension of the alpha conversation, we obtain:</p>
  <div class="math">
    \[\Pi\alpha:*.\alpha\to\alpha\equiv\Pi\beta:*.\beta\to\beta.\]
  </div>
  <h3 id="s3-2">3.2. Second Order Abstraction and Application Rules</h3>
  <p>Since we allow second order abstraction, second order application and <span class="math">\(\Pi\)</span> types, our
  derivation system for <span class="math">\(\lambda_\to\)</span> has to be extended.</p>
  <div class="math">
    \[\begin{array}{lc} (appl_2)&amp;\begin{prooftree}\AXC{$\Gamma\vdash M:\Pi\alpha:*.A$}\AXC{$\Gamma\vdash
    B:*$}\BIC{$\Gamma\vdash MB:A[\alpha:=B]$}\end{prooftree}\\
    (abst_2)&amp;\begin{prooftree}\AXC{$\Gamma,\alpha:*\vdash
    M:A$}\UIC{$\Gamma\vdash\lambda\alpha:*.M:\Pi\alpha:*.A$}\end{prooftree} \end{array}\]
  </div>
  <p>The second order application rule is intuitive, that two types of arbitrary type can be interchanged. This
  abstraction rule also corresponds to our expectations, as presented in the previous section where the <span class=
  "math">\(\Pi\)</span> types are introduced.</p>
  <h3 id="s3-3">3.3. The System <span class="math">\(\lambda2\)</span></h3>
  <p>To describe the complete system, we have to first extend our definition of types. The abstract syntax for
  <span class="math">\(\lambda2\)</span> types is <span class=
  "math">\(\mathbb{T}2=\mathbb{V}\mid(\mathbb{T}2\to\mathbb{T}2)\mid(\Pi\mathbb{V}:*.\mathbb{T}2)\)</span> while
  <span class="math">\(\mathbb{V}\)</span> is the set of type variables.</p>
  <p>Then we extend our set of pre-typed lambda terms so that second order abstraction and application are allowed:</p>
  <div class="math">
    \[\Lambda_{\mathbb{T}2}=V\mid(\Lambda_{\mathbb{T}2}\Lambda_{\mathbb{T}2})\mid(\Lambda_{\mathbb{T}2}\mathbb{T}2)\mid
    (\lambda V:\mathbb{T}2.\Lambda_{\mathbb{T}2})\mid(\lambda\mathbb{V}:*.\Lambda_{\mathbb{T}2}).\]
  </div>
  <p>Note that now we have two classes of variables: object variables <span class="math">\(V\)</span> and type
  variables <span class="math">\(\mathbb{V}\)</span>. We also have first order application <span class=
  "math">\((\Lambda_{\mathbb{T}2}\Lambda_{\mathbb{T}2})\)</span> and second order application <span class=
  "math">\((\Lambda_{\mathbb{T}2}\mathbb{T}2)\)</span> as well as first order abstraction <span class="math">\((\lambda
  V:\mathbb{T}2.\Lambda_{\mathbb{T}2})\)</span> from object variables and second order abstraction <span class=
  "math">\((\lambda\mathbb{V}:*.\Lambda_{\mathbb{T}2})\)</span>.</p>
  <p>The convention is similar to that in untyped and simply typed lambda calculus:</p>
  <ul>
    <li>Outer parentheses may be omitted.</li>
    <li>Application is left-associative.</li>
    <li>Application and <span class="math">\(\to\)</span> takes precedence over both <span class=
    "math">\(\lambda\)</span> and <span class="math">\(\Pi\)</span> abstraction.</li>
    <li>Successive <span class="math">\(\lambda\)</span> or <span class="math">\(\Pi\)</span> abstractions concerning
    the same types may be combined in a right-associative way.</li>
    <li>Arrow types are denoted in a right-associative way.</li>
  </ul>
  <p>The notation of declaration should as well be extended to allow second order declarations:</p>
  <ol>
    <li><em>Statement</em>: Either of the form <span class="math">\(M:\sigma\)</span>, where <span class=
    "math">\(M\in\Lambda_{\mathbb{T}2}\)</span> and <span class="math">\(\sigma\in\mathbb{T}2\)</span>, or of the form
    <span class="math">\(\sigma:*\)</span>, where <span class="math">\(\sigma\in\mathbb{T}2\)</span>.</li>
    <li><em>Declaration</em>: A statement with a <em>term variable</em> or a <em>type variable</em> as subject.</li>
  </ol>
  <p>The rule that all variables must be declared before they can be used motivates the following recursive definition
  of the <span class="math">\(\lambda2\)</span> context, which the new definition of the <em>domain</em> of a context
  is combined:</p>
  <ol>
    <li><span class="math">\(\emptyset\)</span> is a <span class="math">\(\lambda2\)</span> context. Its domain is the
    empty list.</li>
    <li>If <span class="math">\(\Gamma\)</span> is a <span class="math">\(\lambda2\)</span> context, <span class=
    "math">\(\alpha\in\mathbb{V}\)</span> and <span class="math">\(\alpha\notin\mathcal D(\Gamma)\)</span>, then
    <span class="math">\(\Gamma,\alpha:*\)</span> is a <span class="math">\(\lambda2\)</span> context. And <span class=
    "math">\(\mathcal D(\Gamma,\alpha:*)=(\mathcal D(\Gamma),\alpha)\)</span>.</li>
    <li>If <span class="math">\(\Gamma\)</span> is a <span class="math">\(\lambda2\)</span> context, if <span class=
    "math">\(\rho\in\mathbb{T}2\)</span> such that <span class="math">\(\alpha\in\mathcal D(\Gamma)\)</span> for all
    free type variants <span class="math">\(\alpha\)</span> occurring in <span class="math">\(\rho\)</span> and if
    <span class="math">\(x\notin\mathcal D(\Gamma)\)</span>, then <span class="math">\(\Gamma,x:\rho\)</span> is a
    <span class="math">\(\lambda2\)</span> context. And <span class="math">\(\mathcal D(\Gamma,x:\rho)=(\mathcal
    D(\Gamma),x)\)</span>.</li>
  </ol>
  <p>Conforming with the new notion of context, we adapt the variable rule and define the <em>formation rule</em> which
  defines a properly formed <span class="math">\(\lambda2\)</span> type. We assume <span class="math">\(\Gamma\)</span>
  is a <span class="math">\(\lambda2\)</span> context.</p>
  <div class="math">
    \[\begin{array}{lc} (var)&amp;\begin{prooftree}\AXC{$x:\sigma\in\Gamma$}\UIC{$\Gamma\vdash
    x:\sigma$}\end{prooftree}\\ (form)&amp;\begin{prooftree}\AXC{$B\in\mathbb{T}2$}\AXC{$\mathcal
    F(B)\in\Gamma$}\BIC{$\Gamma\vdash B:*$}\end{prooftree} \end{array}\]
  </div>
  <p>Finally, we define the legality of <span class="math">\(\lambda2\)</span>: a term <span class="math">\(M\)</span>
  in <span class="math">\(\Lambda_{\mathbb{T}2}\)</span> is called legal if there exists a <span class=
  "math">\(\lambda2\)</span> context <span class="math">\(\Gamma\)</span> and a type <span class="math">\(\rho\)</span>
  in <span class="math">\(\mathbb{T}2\)</span> such that <span class="math">\(\Gamma\vdash m:\rho\)</span>.</p>
  <h3 id="s3-4">3.4. Properties of <span class="math">\(\lambda2\)</span></h3>
  <p>The definition of alpha conversion is adapted and extended accommodating <span class="math">\(\Pi\)</span>
  types:</p>
  <ol>
    <li><em>Renaming of term variable</em>: <span class="math">\(\lambda x:\sigma.M=_\alpha\lambda y:\sigma.M^{x\to
    y}\)</span> if <span class="math">\(y\notin \mathcal F(M)\)</span> and <span class="math">\(y\)</span> does not
    occur as a binding variable in <span class="math">\(M\)</span>.</li>
    <li><em>Renaming of type variable</em>: <span class=
    "math">\(\lambda\alpha:*.M=_\alpha\lambda\beta:*.M[\alpha:=\beta]\)</span> if <span class="math">\(\beta\)</span>
    does not occur in <span class="math">\(M\)</span> or <span class=
    "math">\(\Pi\alpha:*.M=_\alpha\Pi\beta:*.M[\alpha:=\beta]\)</span> if <span class="math">\(\beta\)</span> does not
    occur in <span class="math">\(M\)</span>.</li>
  </ol>
  <p>We also extend the beta reduction in an obvious way matching the extensions of alpha conversation:</p>
  <ol>
    <li><em>Basis for first order</em>: <span class="math">\((\lambda m:\sigma.M)N\to_\beta M[x:=N]\)</span>.</li>
    <li><em>Basis for second order</em>: <span class="math">\((\lambda\alpha:*.M)T\to_\beta M[\alpha:=T]\)</span>.</li>
  </ol>
  <p>Most properties for <span class="math">\(\lambda_\to\)</span> defined in the previous chapter still applies,
  except the Permutation Lemma, which holds only if the permuted context is a <span class="math">\(\lambda2\)</span>
  context.</p>
  <h2 id="c4">4. Types Dependent on Types</h2>
  <p>In this chapter, we discuss the way to construct <em>generalized types</em>, by abstracting types. This results in
  the system <span class="math">\(\lambda\underline{\omega\!}\,\)</span>.</p>
  <h3 id="s4-1">4.1. Type Constructors</h3>
  <p>We can handle the abstraction of types of terms similar to the way we handle arbitrary types: types like
  <span class="math">\(\beta\to\beta\)</span>, <span class="math">\(\gamma\to\gamma\)</span>, <span class=
  "math">\((\beta\to\gamma)\to(\beta\to\gamma)\)</span> can be generalized using a function <span class=
  "math">\(\lambda\alpha:*.\alpha\to\alpha\)</span> with type as value. This is a so-called <em>type constructor</em>,
  with type <span class="math">\(*\to*\)</span> itself. <em>Proper constructor</em> are the type constructors which are
  not types.</p>
  <p>We name the type of the type constructors consisting of <span class="math">\(*\)</span> alone and of <span class=
  "math">\(*\)</span> symbols with arrows in between <em>kind</em>. They belong to set <span class=
  "math">\(\mathbb{K}\)</span> with abstract syntax <span class=
  "math">\(\mathbb{K}=*\mid(\mathbb{K}\to\mathbb{K})\)</span>. Outermost parentheses may be omitted, and the kinds are
  right-associative. For the type of all kinds, a new symbol <span class="math">\(\square\)</span> is introduced.</p>
  <p>We use the word <em>sort</em> or symbol <span class="math">\(s\)</span> for either <span class="math">\(*\)</span>
  or <span class="math">\(\square\)</span>; by definition, the set of sorts is <span class=
  "math">\(\{*,\square\}\)</span>.</p>
  <p>So now there are four <em>levels</em> in our syntax:</p>
  <ol>
    <li>The terms.</li>
    <li>The constructors (types plus the proper constructors).</li>
    <li>The kinds.</li>
    <li>Solely of type of kinds.</li>
  </ol>
  <h3 id="s4-2">4.2. Sort and Variable in <span class="math">\(\lambda\underline{\omega\!}\,\)</span></h3>
  <p>First, we formalize the fact that the super-type <span class="math">\(*\)</span> is of type <span class=
  "math">\(\square\)</span> using the <em>sort rule</em>.</p>
  <div class="math">
    \[(sort)\quad\emptyset\vdash*:\square\]
  </div>
  <p>The variable rule is used to establish that all declarations occurring in a context is derivable in that context.
  In <span class="math">\(\lambda_\to\)</span>, the set of permissible types was given beforehand. In <span class=
  "math">\(\lambda2\)</span>, we restrict the types of the variables to the recursively defined <span class=
  "math">\(\lambda2\)</span> context. For the more complicated <span class=
  "math">\(\lambda\underline{\omega\!}\,\)</span>, we combine it with the <em>construction of the context
  proper</em>.</p>
  <p>The new approach is that we only extend a context with a declaration <span class="math">\(x:A\)</span> only when
  the type <span class="math">\(A\)</span> is permissible, which is either a type or a kind.</p>
  <div class="math">
    \[(var)\quad\begin{prooftree}\AXC{$\Gamma\vdash A:s$}\AXC{$x\notin\Gamma$}\BIC{$\Gamma,x:A\vdash
    x:A$}\end{prooftree}\]
  </div>
  <p>This rule plays a <em>double role</em> due to the two possibilities of <span class="math">\(s\)</span>.</p>
  <h3 id="s4-3">4.3. Weakening Rule in <span class="math">\(\lambda\underline{\omega\!}\,\)</span></h3>
  <p>When defining the variable rule, the type of the derivable term is restricted to level 2 and 3, since one
  prerequisite is that the type of the derivable term must be of type sort, which is level 4. The solution to this
  limitation is the addition of the <em>weakening rule</em>, which states the fact that the context of a judgment can
  be weakened by adding new declarations provided that the types of the new declarations are well-formed.</p>
  <div class="math">
    \[(weak)\quad\begin{prooftree}\AXC{$\Gamma\vdash A:B$}\AXC{$\Gamma\vdash
    C:s$}\AXC{$x\notin\Gamma$}\TIC{$\Gamma,x:C\vdash A:B$} \end{prooftree}\]
  </div>
  <p>Assuming that we have derived the judgment <span class="math">\(\Gamma\vdash A:B\)</span>, then we may weaken the
  context by adding an arbitrary declaration which type is well-formed at the end. In fact, the Thinning Lemma still
  applies for <span class="math">\(\lambda\underline{\omega\!}\,\)</span>, which means insertion of new declaration is
  allowed at an arbitrary place, however the weakening rule is easy to express and turns out to be sufficient.</p>
  <p>Now that we are able to derive for example <span class="math">\(\alpha:*,\beta:*\vdash\alpha:*\)</span> by proof
  tree.</p>
  <div class="math">
    \[\begin{prooftree}
    \AXC{$\emptyset\vdash*:\square$}\UIC{$\alpha:*\vdash\alpha:*$}\AXC{$\emptyset\vdash*:\square$}\AXC{$\emptyset\vdash*:\square$}
    \BIC{$\alpha:*\vdash*:\square$}\BIC{$\alpha:*,\beta:*\vdash\alpha:*$} \end{prooftree}\]
  </div>
  <h3 id="s4-4">4.4. Formation Rule in <span class="math">\(\lambda\underline{\omega\!}\,\)</span></h3>
  <p>For the construction of typing statements in a context, we have the formation rule. In <span class=
  "math">\(\lambda2\)</span>, the rule was based on a set <span class="math">\(\mathbb{T}2\)</span> of <span class=
  "math">\(\lambda2\)</span> types. While types are more complex in <span class=
  "math">\(\lambda\underline{\omega\!}\,\)</span>, the possibility of double roles makes things become easier.</p>
  <div class="math">
    \[(form)\quad\begin{prooftree}\AXC{$\Gamma\vdash A:s$}\AXC{$\Gamma\vdash B:s$}\BIC{$\Gamma\vdash A\to
    B:s$}\end{prooftree}\]
  </div>
  <h3 id="s4-5">4.5. Application and Abstraction Rules in <span class=
  "math">\(\lambda\underline{\omega\!}\,\)</span></h3>
  <p>The application and abstraction rules differ from the ones in the previous section because of the extended type in
  <span class="math">\(\lambda\underline{\omega\!}\,\)</span> and the lack of <span class="math">\(\Pi\)</span> types.
  Thus the type identifier is changed and a second premiss which the term must be well-formed is added.</p>
  <div class="math">
    \[\begin{array}{lc} (appl)&amp;\begin{prooftree}\AXC{$\Gamma\vdash M:A\to B$}\AXC{$\Gamma\vdash
    N:A$}\BIC{$\Gamma\vdash MN:B$}\end{prooftree}\\ (abst)&amp;\begin{prooftree}\AXC{$\Gamma,x:A\vdash
    M:B$}\AXC{$\Gamma\vdash A\to B:s$}\BIC{$\Gamma\vdash\lambda x:A.M:A\to B$}\end{prooftree} \end{array}\]
  </div>
  <p>The two rules both have a double role again, since <span class="math">\(s\in\{*,\square\}\)</span>.</p>
  <h3 id="s4-6">4.6. Conversion Rule</h3>
  <p>We have applied beta reduction and conversation only on terms before. While the type becomes more complex in
  <span class="math">\(\lambda\underline{\omega\!}\,\)</span>, one will want an other derivation rule which acts on the
  types.</p>
  <div class="math">
    \[(conv)\quad\begin{prooftree}\AXC{$\Gamma\vdash A:B$}\AXC{$\Gamma\vdash B':s$}\AXC{$B=_\beta
    B'$}\TIC{$\Gamma\vdash A:B'$} \end{prooftree}\]
  </div>
  <p>This rule is called the <em>conversion rule</em>, similar to the subject reduction but is intended for types.</p>
  <h3 id="s4-7">4.7. Properties of <span class="math">\(\lambda\underline{\omega\!}\,\)</span></h3>
  <p>The system <span class="math">\(\lambda\underline{\omega\!}\,\)</span> satisfies the majority of the nice
  properties from the previous systems, while only the conversion rule requires a slight modification of the Uniqueness
  of Type Lemma, that types need no longer be literally unique, but they are unique up to conversation.</p>
  <h2 id="c5">5. Type Dependent on Terms</h2>
  <p>In the previous three chapters, we have met <span class="math">\(\lambda_\to\)</span>, the basic system which
  terms depending on terms; <span class="math">\(\lambda2\)</span>, terms depending on types; and <span class=
  "math">\(\lambda\underline{\omega\!}\,\)</span>, types depending on types. In this chapter, we will treat the last
  extension <span class="math">\(\lambda P\)</span> which types are dependent on terms.</p>
  <p>A type depending on a term has general format <span class="math">\(\lambda x:A.M\)</span>, where <span class=
  "math">\(M\)</span> is a type, <span class="math">\(x\)</span> is a term variable, and <span class=
  "math">\(A\)</span> is a type. This abstraction then depends on <span class="math">\(x\)</span>, and is often called
  <em>type-valued function</em> or simply type constructor.</p>
  <p>For instance, let <span class="math">\(V_n=\{\langle v_1,\ldots,v_n\rangle\mid v_i\in\mathbb{N}\}\)</span>, a set
  of all natural number vectors of length <span class="math">\(n\)</span>, then <span class="math">\(\lambda
  n:nat.V_n\)</span> maps <span class="math">\(n\)</span> to the set of all vectors of length <span class=
  "math">\(n\)</span>. It has type <span class="math">\(nat\to*\)</span>.</p>
  <p>Furthermore, we can turn this type-valued function into a predicate. Take <span class="math">\(P_n\)</span> to be
  the proposition <q><span class="math">\(n\)</span> is a prime number</q>, then <span class="math">\(\lambda
  n:nat.P_n\)</span> is the logical predicate <q>to be a prime</q>. This is the PAT-interpretation introduced with
  <span class="math">\(\lambda_\to\)</span>, the first step to a fruitful treatment of proof in formal logic and
  mathematics.</p>
  <h3 id="s5-1">5.1. Derivation Rules of <span class="math">\(\lambda P\)</span></h3>
  <p>The derivation rules of <span class="math">\(\lambda P\)</span> has a great resemblance to the rules of
  <span class="math">\(\lambda\underline{\omega\!}\,\)</span>, so we present them directly.</p>
  <div class="math">
    \[\begin{array}{lc} (sort)&amp;\emptyset\vdash*:\square\\ (var)&amp;\begin{prooftree}\AXC{$\Gamma\vdash
    A:s$}\AXC{$x\notin\Gamma$}\BIC{$\Gamma,x:A\vdash x:A$}\end{prooftree}\\
    (weak)&amp;\begin{prooftree}\AXC{$\Gamma\vdash A:B$}\AXC{$\Gamma\vdash
    C:s$}\AXC{$x\notin\Gamma$}\TIC{$\Gamma,x:C\vdash A:B$}\end{prooftree}\\
    (form)&amp;\begin{prooftree}\AXC{$\Gamma\vdash A:*$}\AXC{$\Gamma,x:A\vdash B:s$}\BIC{$\Gamma\vdash\Pi
    x:A.B:s$}\end{prooftree}\\ (appl)&amp;\begin{prooftree}\AXC{$\Gamma\vdash M:\Pi x:A.B$}\AXC{$\Gamma\vdash
    N:A$}\BIC{$\Gamma\vdash MN:B[x:=N]$}\end{prooftree}\\ (abst)&amp;\begin{prooftree}\AXC{$\Gamma,x:A\vdash
    M:B$}\AXC{$\Gamma\vdash\Pi x:A.B:s$}\BIC{$\Gamma\vdash\lambda x:A.M:\Pi x:A.B$} \end{prooftree}\\
    (conv)&amp;\begin{prooftree}\AXC{$\Gamma\vdash A:B$}\AXC{$\Gamma\vdash B':s$}\AXC{$B=_\beta B'$}\TIC{$\Gamma\vdash
    A:B'$}\end{prooftree} \end{array}\]
  </div>
  <p>The main differences with respect to <span class="math">\(\lambda\underline{\omega\!}\,\)</span> are:</p>
  <ol>
    <li>The appearance of <span class="math">\(\Pi\)</span> types instead of the <span class="math">\(\to\)</span>
    types, which means <span class="math">\(B\)</span> is generalized so that <span class="math">\(x\)</span> can
    appear as a free variable, thus a <em>dependent product</em>, which the output type depends on the input
    value.</li>
    <li>The input type can not be dependent on types anymore, so that it can only have type <span class=
    "math">\(*\)</span>.</li>
  </ol>
  <p>The formation rule is also called the product rule, since it enables the construction and typing of a <span class=
  "math">\(\Pi\)</span> type. Martin-Löf calls a <span class="math">\(\Pi\)</span> type the cartesian product of a
  family of types. So <span class="math">\(\Pi\)</span> types can both be seen as a generalization of the cartesian
  product (consider <span class="math">\(A=\{a_1,a_2\}\)</span>, then <span class="math">\(\Pi x:A.B\)</span> is the
  same as <span class="math">\(B[x:=a_1]\times B[x:=a_2]\)</span>) and as a generalization of the function space (if
  <span class="math">\(x\notin\mathcal F(B)\)</span>, then <span class="math">\(\Pi x:A.B\)</span> is just <span class=
  "math">\(A\to B\)</span>).</p>
  <h3 id="s5-2">5.2. Minimal Predicate Logic</h3>
  <p>We can code <em>minimal predicate logic</em> which only has <em>implication</em> and <em>universal
  qualification</em> as logic operations with basic entities <em>propositions</em>, <em>sets</em> and <em>predicates
  over sets</em> in <span class="math">\(\lambda P\)</span>.</p>
  <p>We first investigate the coding of the basic entities of minimal predicate logic and apply the full PAT
  interpretation in the appropriate cases.</p>
  <ol>
    <li>We code a set <span class="math">\(S\)</span> as a type, so <span class="math">\(S:*\)</span>. Then, the
    elements of the sets are terms.</li>
    <li>Propositions are coded as types. Let <span class="math">\(A\)</span> be a proposition, then <span class=
    "math">\(A:*\)</span>. A term <span class="math">\(p\)</span> inhabiting such <span class="math">\(A\)</span> codes
    a <em>proof</em> of <span class="math">\(A\)</span>.</li>
    <li>A predicate <span class="math">\(P\)</span> is a function from a set <span class="math">\(S\)</span> to set of
    all propositions. Therefore <span class="math">\(P:S\to*\)</span>. If this function with a term applied is
    inhabited, then the predicate hold, and vice versa.</li>
    <li>The implication <span class="math">\(A\Rightarrow B\)</span> is coded as the function type <span class=
    "math">\(A\to B\)</span> in type theory. Note that propositions are independent from each other, so there is no
    need to consider <span class="math">\(\Pi\)</span> types here.</li>
    <li>We code the universal qualification <span class="math">\(\forall_{x\in S}(P(x))\)</span> as the <span class=
    "math">\(\Pi\)</span> type <span class="math">\(\Pi x:S.Px\)</span>. And it turns out that the elimination and
    introduction rules are a special case of the abstraction and application rules of <span class="math">\(\lambda
    P\)</span>.</li>
  </ol>
  <p>An example of minimal predication logic is given. Let <span class="math">\(S\)</span> be a set and <span class=
  "math">\(Q\)</span> a binary predicate over <span class="math">\(S\)</span>, what we want to prove is <span class=
  "math">\(\forall_{x\in S}\forall_{y\in S}(Q(x,y))\Rightarrow\forall_{u\in S}(Q(u,u))\)</span>. We define a local
  environment <span class="math">\(\Delta=\{S:*,Q:S\to S\to*\}\)</span> for this.</p>
  <div class="math">
    \[\begin{prooftree} \AXC{$\Delta,z:\Pi x:S.\Pi y:S.Qxy,u:S\vdash z:\Pi x:S.\Pi y:S.Qxy$}\AXC{$\Delta,z:\Pi x:S.\Pi
    y:S.Qxy,u:S\vdash u:S$} \BIC{$\Delta,z:\Pi x:S.\Pi y:S.Qxy,u:S\vdash zu:\Pi y:S.Quy$}\AXC{$\Delta,z:\Pi x:S.\Pi
    y:S.Qxy,u:S\vdash u:S$} \BIC{$\Delta,z:\Pi x:S.\Pi y:S.Qxy,u:S\vdash zuu:Quu$}\UIC{$\Delta,z:\Pi x:S.\Pi
    y:S.Qxy\vdash\lambda u:S.zuu:\Pi u:S.Quu$} \UIC{$\Delta\vdash\lambda z:\Pi x:S.\Pi y:S.Qxy.\lambda u:S.zuu:\Pi
    x:S.\Pi y:S.Qxy\to\Pi u:S.Quu$} \end{prooftree}\]
  </div>
  <p>This is identical to a term finding process, and the proposition is proved since we succeeded in finding an
  inhabitant for the type representing the proposition.</p>
</body>
</html>
